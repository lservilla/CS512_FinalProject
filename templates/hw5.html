<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>HW5</title>
  <style>
    html,body{
      height:100%;
      margin:0;
      background:#111;
      color:#ddd;
      font-family:monospace;}

    canvas{
      display:block;
      margin:24px auto;
      border:1px solid #444;
      width:640px;
      height:480px;
      image-rendering:pixelated;}

    .title{text-align:center;}

    #video{
      position:fixed;
      left:0;
      top:0;
      width:2px;
      height:2px;
      opacity:0.01;
      pointer-events:none;}

  </style>
</head>
<body>
  <div class="title">Basic texture with fur normal mapping for the teddy bear and hand drawn ghost video</div>

  <canvas id="glcanvas" width="640" height="480"></canvas>

  <video id="video" src="{{ video_url }}?v={{ cache_bust }}" autoplay loop muted playsinline></video>

  <script src="{{ url_for('static', filename='transformations.js') }}"></script>
  <script src="{{ url_for('static', filename='primitives.js') }}"></script>

  <script>

  // Matrix helpers 
  const I=mat4Identity, 
        MM=(A,B)=>multiplyMat4(A,B),
        T=(M,x,y,z)=>mat4Translate(M,[x,y,z]),
        RX=(M,a)=>mat4RotateX(M,a),
        RY=(M,a)=>mat4RotateY(M,a),
        RZ=(M,a)=>mat4RotateZ(M,a),
        S=(M,sx,sy,sz)=>mat4Scale(M,[sx,sy,sz]),
        N3=(V,M)=>normalMatrixFromMV(multiplyMat4(V,M));

  const Pm=(f,a,n,fa)=>new Float32Array(perspective(f,a,n,fa));

  function TRS(t=[0,0,0],r=[0,0,0],s=[1,1,1]){
    let M=I();
    M=T(M,t[0],t[1],t[2]);
    if(r){
      if(r[0])M=RX(M,r[0]);
      if(r[1])M=RY(M,r[1]);
      if(r[2])M=RZ(M,r[2]);
    }
    return S(M,s[0],s[1],s[2]);
  }

  //  WebGL initiation
  const gl=document.getElementById("glcanvas").getContext("webgl2",{alpha:false,antialias:true});

  gl.enable(gl.DEPTH_TEST);
  gl.depthFunc(gl.LESS);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);

  // Setting up functions to use for using multiple vertex and fragment shaders in the same canvas
  function compile(t,s){
    const sh=gl.createShader(t);
    gl.shaderSource(sh,s);
    gl.compileShader(sh);
    return sh;
  }

  function link(vs,fs){
    const p=gl.createProgram();
    gl.attachShader(p,compile(gl.VERTEX_SHADER,vs));
    gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fs));
    gl.linkProgram(p);
    return p;
  }

  // Video shaders, super basic 
  const vertexShaderVid=`#version 300 es
  in vec3 aPos;
  in vec2 aUV;

  uniform mat4 uMVP;

  out vec2 vUV;

  void main(){
    vUV=aUV;
    gl_Position=uMVP*vec4(aPos,1.0);
  }`;

  const fragmentShaderVid=`#version 300 es
  precision mediump float;

  in vec2 vUV;

  uniform sampler2D uTex;
  uniform bool uUseVideo;
  uniform vec3 uColor;

  out vec4 fragColor;

  void main(){
    vec3 base=uUseVideo?texture(uTex,vUV).rgb:uColor;
    fragColor=vec4(base,1.0);
  }`;
  
  const vidShader=link(vertexShaderVid,fragmentShaderVid);

  const aPosA=gl.getAttribLocation(vidShader,"aPos"),
        aUVA=gl.getAttribLocation(vidShader,"aUV");

  const uMVPA=gl.getUniformLocation(vidShader,"uMVP"),
        uTexA=gl.getUniformLocation(vidShader,"uTex"),
        uUseVideoA=gl.getUniformLocation(vidShader,"uUseVideo"),
        uColorA=gl.getUniformLocation(vidShader,"uColor");

  gl.useProgram(vidShader);
  gl.uniform1i(uTexA,0);


  // Teddy texture shader, mostly using the lighting from HW3 claw machine
  const vertexShaderTed=`#version 300 es
  in vec3 aPos, aNormal, aTangent, aPos2, aNormal2;
  in vec2 aUV;

  uniform mat4 uP, uV, uM;
  uniform mat3 uN3;
  uniform float uMorph;

  out vec3 vPosVS;
  out vec3 vNormalVS;
  out vec2 vUV;
  out mat3 vTBN;

  void main(){
    vec3 pos=mix(aPos,aPos2,uMorph);
    vec3 nor=normalize(mix(aNormal,aNormal2,uMorph));
    vec4 posVS=uV*uM*vec4(pos,1.0);
    gl_Position=uP*posVS;
    vec3 N=normalize(uN3*nor);
    vec3 T=normalize(uN3*aTangent-N*dot(N,uN3*aTangent));
    vec3 B=cross(N,T);
    vTBN=mat3(T,B,N);
    vPosVS=posVS.xyz;
    vNormalVS=N;
    vUV=aUV;
  }`;

  const fragmentShaderTed=`#version 300 es
  precision mediump float;

  in vec3 vPosVS, vNormalVS;
  in vec2 vUV;
  in mat3 vTBN;

  uniform sampler2D uAlbedo, uNormal;
  uniform vec3 uLightDirVS;
  uniform float uAmbient, uSpecPower, uSpecStrength;
  uniform float uDepthNear, uDepthFar, uDepthMin;

  out vec4 fragColor;

  void main(){
    vec3 nTex=texture(uNormal,vUV*2.0).rgb*2.0-1.0;
    vec3 N=normalize(vTBN*nTex);
    vec3 L=normalize(-uLightDirVS);
    vec3 V=normalize(-vPosVS);
    vec3 H=normalize(L+V);
    float NdotL=max(dot(N,L),0.0);
    float spec=pow(max(dot(N,H),0.0),uSpecPower);
    vec3 base=texture(uAlbedo,vUV*2.0).rgb;
    vec3 lit=base*(uAmbient+NdotL)+vec3(spec)*uSpecStrength;
    float d=length(vPosVS);
    float t=clamp((d-uDepthNear)/(uDepthFar-uDepthNear),0.0,1.0);
    t=smoothstep(0.0,1.0,t);
    float depthShade=mix(1.0,uDepthMin,t);
    fragColor=vec4(lit*depthShade,1.0);
  }`;

  const tedShader=link(vertexShaderTed,fragmentShaderTed);
  const tedAtLocations={
    aPos:gl.getAttribLocation(tedShader,"aPos"),
    aNormal:gl.getAttribLocation(tedShader,"aNormal"),
    aTangent:gl.getAttribLocation(tedShader,"aTangent"),
    aUV:gl.getAttribLocation(tedShader,"aUV"),
    aPos2:gl.getAttribLocation(tedShader,"aPos2"),
    aNormal2:gl.getAttribLocation(tedShader,"aNormal2"),
    uP:gl.getUniformLocation(tedShader,"uP"),
    uV:gl.getUniformLocation(tedShader,"uV"),
    uM:gl.getUniformLocation(tedShader,"uM"),
    uN3:gl.getUniformLocation(tedShader,"uN3"),
    uAlbedo:gl.getUniformLocation(tedShader,"uAlbedo"),
    uNormal:gl.getUniformLocation(tedShader,"uNormal"),
    uMorph:gl.getUniformLocation(tedShader,"uMorph"),
    uLightDirVS:gl.getUniformLocation(tedShader,"uLightDirVS"),
    uAmbient:gl.getUniformLocation(tedShader,"uAmbient"),
    uSpecPower:gl.getUniformLocation(tedShader,"uSpecPower"),
    uSpecStrength:gl.getUniformLocation(tedShader,"uSpecStrength"),
    uDepthNear:gl.getUniformLocation(tedShader,"uDepthNear"),
    uDepthFar:gl.getUniformLocation(tedShader,"uDepthFar"),
    uDepthMin:gl.getUniformLocation(tedShader,"uDepthMin")
  };

  // Loading the fur texture normal and albedo for color
  function loadTexturePNG(url,repeat=false){
    const t=gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,t);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,255]));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, repeat?gl.REPEAT:gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, repeat?gl.REPEAT:gl.CLAMP_TO_EDGE);

    const img=new Image();

    img.onload=()=>{gl.bindTexture(gl.TEXTURE_2D, t);
                    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    gl.generateMipmap(gl.TEXTURE_2D);};
    img.src=url; 
    return t;
  }

  const texAlbedo=loadTexturePNG("{{ url_for('static', filename='stylized-animal-fur-unity/stylized-animal-fur_albedo.png') }}",true);
  const texNormal=loadTexturePNG("{{ url_for('static', filename='stylized-animal-fur-unity/stylized-animal-fur_normal-ogl.png') }}",true);

  // Setting up video texture
  const video=document.getElementById("video");
  const videoTex=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, videoTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA,gl.UNSIGNED_BYTE, new Uint8Array([0,0,0,255]));
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  video.play().catch(()=>{});

  // Setting up UVs for the block, manualy adding 
  function makeTexturedBlock(w=2,h=2,d=2){
    const prim=buildBlock(w,h,d);
    const uvs=new Float32Array([
      // +Z
      0,0, 1,0, 1,1, 0,1,
      // -Z
      1,0, 0,0, 0,1, 1,1,
      // +Y
      0,0, 1,0, 1,1, 0,1,
      // -Y
      0,1, 1,1, 1,0, 0,0,
      // +X
      0,0, 0,1, 1,1, 1,0,
      // -X
      0,0, 1,0, 1,1, 0,1,
    ]);
    return{positions: prim.positions, indices:prim.indices, uvs};
  }

  function createGLMeshVid(mesh){

    const pos=gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, pos);
              gl.bufferData(gl.ARRAY_BUFFER, mesh.positions, gl.STATIC_DRAW);

    const uv=gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER,  uv);
    const uvs=mesh.uvs||new Float32Array(mesh.positions.length/3*2);
              gl.bufferData(gl.ARRAY_BUFFER,  uvs,  gl.STATIC_DRAW);
    const idx=gl.createBuffer();
              gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,  idx);
              gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,  mesh.indices, gl.STATIC_DRAW);

    return{pos, uv, idx,  count:mesh.indices.length};
  }
  const cubeGL=createGLMeshVid(makeTexturedBlock(2,2,2));

  // Setting up UVs for cylinder
  function addCylindricalUVs(mesh){
    const pos=mesh.positions;
    const nVerts=pos.length/3;
    const uvs=new Float32Array(nVerts*2);

    // find vertical range
    let minY=Infinity,maxY=-Infinity;
    for(let i=0;i<nVerts;i++){
      const y=pos[i*3+1];
      if(y<minY)minY=y;
      if(y>maxY)maxY=y;
    }
    const rangeY=(maxY-minY)||1.0;

    for(let i=0;i<nVerts;i++){
      const x=pos[i*3+0];
      const y=pos[i*3+1];
      const z=pos[i*3+2];

      // angle around Y axis -> U
      let angle=Math.atan2(z,x); // -pi..pi
      let u=angle/(2.0*Math.PI); // -0.5..0.5
      if(u<0.0)u+=1.0;           // 0..1

      const v=(y-minY)/rangeY;   // 0..1 from bottom to top

      uvs[i*2+0]=u;
      uvs[i*2+1]=v;
    }
    mesh.uvs=uvs;
  }

  const cyl=buildCylinder(0.9,0.9,2.0,96);
  addCylindricalUVs(cyl);              
  const cylinderGL=createGLMeshVid(cyl);


  // Setting up sphere used for the teddy bear
  const sphere=buildSphere(1,32,48);

  // Finding sphere tangent to properly map normal texture to world 
  function computeTangents(p){
    const n=p.length/3, t=new Float32Array(n*3);
    for(let i=0; i<n; i++){
      let x=p[i*3], y=p[i*3+1], z=p[i*3+2];
      let L=Math.hypot(x,y,z)||1;
      let nx=x/L, ny=y/L, nz=z/L;
      let vx=1, vy=0, vz=0;
      if(Math.abs(nx)>0.9){vx=0;vy=1;vz=0;}
      let ndv=nx*vx+ny*vy+nz*vz;
      vx-=nx*ndv;
      vy-=ny*ndv;
      vz-=nz*ndv;
      let vL=Math.hypot(vx,vy,vz)||1;
      t.set([vx/vL,vy/vL,vz/vL],i*3);
    }
    return t;
  }

  const tangents=computeTangents(sphere.positions);

  function createSphereGL(base){
    const b={};
    b.pos=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, b.pos);
          gl.bufferData(gl.ARRAY_BUFFER, base.positions, gl.STATIC_DRAW);

    b.nor=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, b.nor);
          gl.bufferData(gl.ARRAY_BUFFER, base.normals, gl.STATIC_DRAW);

    b.tan=gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, b.tan);
          gl.bufferData(gl.ARRAY_BUFFER, tangents, gl.STATIC_DRAW);

    const vertsAcross=49, vertsDown=33;
    const uvs=new Float32Array(vertsAcross*vertsDown*2);
    let p=0;
    for (let y = 0; y < vertsDown; y++) {
      const v = 1 - (y / (vertsDown - 1));
      for (let x = 0; x < vertsAcross; x++) {
        const u = x / (vertsAcross - 1);
        uvs[p++] = u;
        uvs[p++] = v;
      }
    }

    b.uv=gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, b.uv);
    gl.bufferData(gl.ARRAY_BUFFER, uvs,gl.STATIC_DRAW);
    b.p2=b.pos;
    b.n2=b.nor;
    b.idx=gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, b.idx);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, base.indices, gl.STATIC_DRAW);
    b.count=base.indices.length;
    return b;
  }
  const sphereGL=createSphereGL(sphere);

  const bearLimbs = {
    body: { pos:[ 0.0, 0.0, 0.0],   rot:[0,0,0],            scale:[1.0, 1.3, 1.10], morphBase:0.0 },
    head: { pos:[ 0.0, 1.7 ,0.0],   rot:[0,0,0],            scale:[0.90,0.8,0.80],  morphBase:0.0 },
    earL: { pos:[-0.7, 2.6, -0.5],  rot:[0,0,0],            scale:[0.35,0.35,0.22], morphBase:0.0 },
    earR: { pos:[ 0.7, 2.6, -0.5],  rot:[0,0,0],            scale:[0.35,0.35,0.22], morphBase:0.0 },
    snout:{ pos:[ 0.00, 1.4, 0.55], rot:[0,0,0],            scale:[0.45,0.35,0.55], morphBase:0.0 },
    armL: { pos:[-1.20, 0.3,0.05],  rot:[-0.50, 0.3, 0.65], scale:[0.3,1.0,0.3],    morphBase:0.0 },
    armR: { pos:[ 1.20, 0.3,0.05],  rot:[-0.50,-0.3,-0.65], scale:[0.3,1.0,0.3],    morphBase:0.0 },
    legL: { pos:[-0.9,-1.65,-1.0],  rot:[-0.60, 0, 0.4],    scale:[0.4,1.2,0.45],   morphBase:0.0 },
    legR: { pos:[ 0.9,-1.65, -1.0], rot:[-0.60, 0,-0.4],    scale:[0.4,1.2,0.45],   morphBase:0.0 },
    pawL: { pos:[-1.2,-2.0,0.35],   rot:[0.0,0,0.6],        scale:[0.48,0.28,0.48], morphBase:0.0 },
    pawR: { pos:[ 1.2,-2.0,0.35],   rot:[0.0,0,-0.6],       scale:[0.48,0.28,0.48], morphBase:0.0 },
    pawLA:{ pos:[-1.65,-0.35,0.35], rot:[0.0,0,-0.8],       scale:[0.38,0.28,0.48], morphBase:0.0 },
    pawRA:{ pos:[ 1.65,-0.35,0.35], rot:[0.0,0, 0.8],       scale:[0.38,0.28,0.48], morphBase:0.0 },
  };
  const parts = ['body','head','earL','earR','snout','armL','armR','legL','legR','pawL','pawR','pawLA','pawRA'];

  const Pmat=Pm(Math.PI/3,gl.canvas.width/gl.canvas.height,0.1,100);
  const Vmat=T(I(),0,0,-8);

  function setLighting(){ // Using the same lighting set up as the claw game 
    gl.uniform3f(tedAtLocations.uLightDirVS,0.3,-0.9,0.4);
    gl.uniform1f(tedAtLocations.uAmbient,0.55);
    gl.uniform1f(tedAtLocations.uSpecPower,42.0);
    gl.uniform1f(tedAtLocations.uSpecStrength,0.65);
    gl.uniform1f(tedAtLocations.uDepthNear,15.0);
    gl.uniform1f(tedAtLocations.uDepthFar,120.0);
    gl.uniform1f(tedAtLocations.uDepthMin,0.35);
  }

  function bindSphere(g){
    gl.bindBuffer(gl.ARRAY_BUFFER, g.pos);
    gl.enableVertexAttribArray(tedAtLocations.aPos);
    gl.vertexAttribPointer(tedAtLocations.aPos, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, g.nor);
    gl.enableVertexAttribArray(tedAtLocations.aNormal);
    gl.vertexAttribPointer(tedAtLocations.aNormal, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, g.tan);
    gl.enableVertexAttribArray(tedAtLocations.aTangent);
    gl.vertexAttribPointer(tedAtLocations.aTangent, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, g.uv);
    gl.enableVertexAttribArray(tedAtLocations.aUV);
    gl.vertexAttribPointer(tedAtLocations.aUV, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, g.p2);
    gl.enableVertexAttribArray(tedAtLocations.aPos2);
    gl.vertexAttribPointer(tedAtLocations.aPos2, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, g.n2);
    gl.enableVertexAttribArray(tedAtLocations.aNormal2);
    gl.vertexAttribPointer(tedAtLocations.aNormal2, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,g.idx);
  }

  function drawSphereInstance(g, M){
    gl.uniformMatrix4fv(tedAtLocations.uM, false, M);
    gl.uniformMatrix3fv(tedAtLocations.uN3, false, N3(Vmat, M));
    gl.uniform1f(tedAtLocations.uMorph, 0.0);
    bindSphere(g);
    gl.drawElements(gl.TRIANGLES, g.count, gl.UNSIGNED_SHORT, 0);
  }

  function drawBear(){
    gl.useProgram(tedShader);
    gl.uniformMatrix4fv(tedAtLocations.uP, false, Pmat);
    gl.uniformMatrix4fv(tedAtLocations.uV, false, Vmat);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texAlbedo);
    gl.uniform1i(tedAtLocations.uAlbedo, 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, texNormal);
    gl.uniform1i(tedAtLocations.uNormal, 1);

    setLighting();

    gl.depthMask(false);

    for(const n of parts){
      const p=bearLimbs[n];
      const M=TRS(p.pos, p.rot, p.scale);
      drawSphereInstance(sphereGL, M);
    }

    gl.depthMask(true);
  }

  function drawMeshVid(mesh, M, useVideo, color){
    gl.useProgram(vidShader);
    const MVP=MM(MM(Pmat, Vmat), M);

    gl.uniformMatrix4fv(uMVPA, false, MVP);
    gl.uniform1i(uUseVideoA, useVideo?1:0);

    if(!useVideo&&color)gl.uniform3f(uColorA, color[0], color[1], color[2]);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, videoTex);

    gl.bindBuffer(gl.ARRAY_BUFFER, mesh.pos);
    gl.enableVertexAttribArray(aPosA);
    gl.vertexAttribPointer(aPosA, 3, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER,mesh.uv);
    gl.enableVertexAttribArray(aUVA);
    gl.vertexAttribPointer(aUVA, 2, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.idx);

    gl.disable(gl.CULL_FACE);
    gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
    gl.enable(gl.CULL_FACE);
  }

  function renderLoop(t){
    const time=t*0.001;
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, videoTex);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clearColor(0.07, 0.07, 0.08, 1);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    let M=I();
    M=T(M,-3.6,-1.6,0);
    M=RY(M,time*0.9);
    drawMeshVid(cubeGL, M, true, null);

    M=I();
    M=T(M,3.6,-1.6,0);
    M=RY(M,time*0.6);
    drawMeshVid(cylinderGL, M, true, null); 

    gl.disable(gl.DEPTH_TEST);
    drawBear();
    gl.enable(gl.DEPTH_TEST);

    requestAnimationFrame(renderLoop);
  }

  video.addEventListener("canplay",()=>requestAnimationFrame(renderLoop));
  document.addEventListener("click",()=>{if(video.paused)video.play();},{once:true});
  </script>
</body>
</html>




